[
  {
    "objectID": "vaesto.html",
    "href": "vaesto.html",
    "title": "Väestönmuutokset",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "vaesto.html#kuntien-välinen-nettomuutto---viimeiset-12kk",
    "href": "vaesto.html#kuntien-välinen-nettomuutto---viimeiset-12kk",
    "title": "Väestönmuutokset",
    "section": "Kuntien välinen nettomuutto - viimeiset 12kk",
    "text": "Kuntien välinen nettomuutto - viimeiset 12kk\n\ndata_migr = (await FileAttachmentDynamic(migrBetwMuniMapCSV).csv()).map((d) =&gt; (d.muutos = +d.muutos, d))\n\n//Väritetään kartta\nmapInterpolateRdBu_migr = d3.scaleDiverging([-150, 0, 150], d3.interpolatePiYG);\n\nborderColorDark_migr = \"#525252\";\n\n//Piirretään kartta\nchart_map_d3(data_migr, mapTopoJSON, mapInterpolateRdBu_migr, borderColorDark_migr, title_txt_map_migr,chart_width_migr,chart_height_migr)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_map_d3(data_migr, mapTopoJSON, mapInterpolateRdBu_migr, borderColorDark_migr, title_txt_map_migr,chart_width_migr,chart_height_migr)), title_txt_map_migr, \"Save as SVG\")\n\n\n\n\n\n\n\n\n\nKuntien välinen nettomuutto - viimeiset 12kk, top20"
  },
  {
    "objectID": "vaesto.html#väestönmuutokset---väestöennakko",
    "href": "vaesto.html#väestönmuutokset---väestöennakko",
    "title": "Väestönmuutokset",
    "section": "Väestönmuutokset - Väestöennakko",
    "text": "Väestönmuutokset - Väestöennakko\n\n\n\n\n\n\n\nEnnakkotiedot\nEnnakkotietojen (2024M07) perusteella Kangasalan väkiluku on kasvanut 0.04 %. (2024M06: 0.09 %). Uusin väestön ennakkotieto on 33757 (edell. lukema 33744). Vuoden alusta (2023: 33473) väkiluku on kasvanut 0.85 %."
  },
  {
    "objectID": "vaesto.html#väkiluvun-muutos--vuoden-2023-lopusta",
    "href": "vaesto.html#väkiluvun-muutos--vuoden-2023-lopusta",
    "title": "Väestönmuutokset",
    "section": "Väkiluvun muutos-% vuoden 2023 lopusta",
    "text": "Väkiluvun muutos-% vuoden 2023 lopusta\n\ndata = (await FileAttachmentDynamic(populationMapCSV).csv()).map((d) =&gt; (d.muutos = +d.muutos, d))\n\n//Väritetään kartta\n//mapInterpolateRdBu = d3.scaleDiverging([domain_min, 0, domain_max], d3.interpolateRdBu);\nmapInterpolateRdBu = d3.scaleDiverging([-1.5, 0, 1.5], d3.interpolatePiYG);\n\nborderColorDark = \"#525252\";\n\n//Piirretään kartta\nchart_map_d3(data, mapTopoJSON, mapInterpolateRdBu, borderColorDark, title_txt_map,chart_width,chart_height)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_map_d3(data, mapTopoJSON, mapInterpolateRdBu, borderColorDark, title_txt_map,chart_width,chart_height)), title_txt_map, \"Save as SVG\")"
  },
  {
    "objectID": "vaesto.html#koko-maa---top-20",
    "href": "vaesto.html#koko-maa---top-20",
    "title": "Väestönmuutokset",
    "section": "Koko maa - top 20",
    "text": "Koko maa - top 20"
  },
  {
    "objectID": "syntyvyys.html",
    "href": "syntyvyys.html",
    "title": "Syntyvyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "syntyvyys.html#luonnollinen-väestönkasvu",
    "href": "syntyvyys.html#luonnollinen-väestönkasvu",
    "title": "Syntyvyys",
    "section": "Luonnollinen väestönkasvu",
    "text": "Luonnollinen väestönkasvu\n\nLuonnollinen väestönlisäys\n\n\n\n\n\n\nSyntyneiden enemmyys eli luonnollinen väestönlisäys tarkoittaa elävänä syntyneiden ja kuolleiden erotusta.\nLuonnollinen väestönlisäys ajanjaksolla 2024Q1* - 2024Q2* oli yhteensä 14 (2024Q1*: 15). Vuosina 2022 ja 2023 luonnollinen väestönlisäys oli 2022: -13 ja 2023: -20"
  },
  {
    "objectID": "syntyvyys.html#syntyneet",
    "href": "syntyvyys.html#syntyneet",
    "title": "Syntyvyys",
    "section": "Syntyneet",
    "text": "Syntyneet\n\nSyntyvyys\n\n\n\n\n\n\n\n\nSyntyvyys\nSyntyvyys ajanjaksolla 2024Q1* - 2024Q2* oli yhteensä 162 (lukema 2024Q1* oli 87). Vuosina 2022 ja 2023 syntyvyys oli lukemissa (2022) 287 ja (2023) 292. :::"
  },
  {
    "objectID": "syntyvyys.html#väestönmuutokset---väestöpyramidi",
    "href": "syntyvyys.html#väestönmuutokset---väestöpyramidi",
    "title": "Syntyvyys",
    "section": "Väestönmuutokset - Väestöpyramidi",
    "text": "Väestönmuutokset - Väestöpyramidi\n\nDOM.download(() =&gt; serialize(pyramid), \"Väestöpyramidi\", \"Save as SVG\")\n\n\n\n\n\n\n\npyramid_pop_data = FileAttachmentDynamic(pyramid_pop_csv).csv({typed: true})\n\ntranslations = ({\n  v1990: \"1990\",\n  v2010: \"2010\",\n  v2024: valitut_kk_tahti\n  })\n\npyramid = toSVG(Plot.plot({\n  width: 600,\n  height: 600,\n  marginTop: 20,\n  marginRight: 20,\n  marginBottom: 30,\n  marginLeft: 40,\n  x: {\n    label: \"← mies · väestö · nainen →\",\n    labelAnchor: \"center\",\n    tickFormat: Math.abs,\n    //domain: [-300, 300]\n  },\n  y: {grid: true},\n  color: {\n    width: 300,\n    domain: [\"v1990\", \"v2010\", \"v2024\"],\n    range: [\"#e41a1c\", \"#377eb8\", \"#4daf4a\"],\n    legend: true,\n    className: 'large-font',\n    tickFormat: (d) =&gt; translations[d]\n  },\n  style: {\n    fontSize: 14\n  },\n  marks: [\n    Plot.lineX(pyramid_pop_data, {\n      x: (d) =&gt; d.population * (d.sex === \"Miehet\" ? -1 : 1),\n      y: \"age\",\n      z: (d) =&gt; [d.sex, d.category].join(\",\"),\n      stroke: \"category\",\n      strokeWidth: 4,\n      fill: \"category\",\n      fillOpacity: 0\n    }),\n    Plot.ruleX([0]),\n    Plot.ruleY([0])\n  ]\n}))"
  },
  {
    "objectID": "kansainvalisyys.html",
    "href": "kansainvalisyys.html",
    "title": "Kansainvälisyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "kansainvalisyys.html#kansainvälisyys---maahanmuutto-ja-nettomaahanmuutto",
    "href": "kansainvalisyys.html#kansainvälisyys---maahanmuutto-ja-nettomaahanmuutto",
    "title": "Kansainvälisyys",
    "section": "Kansainvälisyys - Maahanmuutto ja nettomaahanmuutto",
    "text": "Kansainvälisyys - Maahanmuutto ja nettomaahanmuutto\n\n\n\n\n\n\n\nMaahanmuutto ja nettomaahanmuutto\nKumulatiivinen nettomaahanmuutto oli vuoden alusta tähän hetkeen 2024M07* yhteensä 28. Edellisvuoden lukema nettomaahanmuutossa oli 71. Erotusta nettomaahanmuutossa viime vuoteen on yhteensä -43 henkilöä. Pohjoismaista oli muuttanut yhteensä yhteensä 2 henkilöä ja muista EU-maista 9 henkilöä. Kokonaisuudessaan maahanmuuttajia oli yhteensä 44.\nNettomaahanmuutto (tai nettosiirtolaisuus) on maahanmuuton ja maastamuuton erotus. Lähde: Tilastokeskus"
  },
  {
    "objectID": "asuminen.html",
    "href": "asuminen.html",
    "title": "Asuminen",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "asuminen.html#asuminen---asuntokunnat-talotyypeittäin",
    "href": "asuminen.html#asuminen---asuntokunnat-talotyypeittäin",
    "title": "Asuminen",
    "section": "Asuminen - Asuntokunnat talotyypeittäin",
    "text": "Asuminen - Asuntokunnat talotyypeittäin\n\n\n\n\n\n\nTähän tekstiä…"
  },
  {
    "objectID": "asuminen.html#asuminen---asuntokunnat-talotyypin-ja-koon-mukaan",
    "href": "asuminen.html#asuminen---asuntokunnat-talotyypin-ja-koon-mukaan",
    "title": "Asuminen",
    "section": "Asuminen - Asuntokunnat talotyypin ja koon mukaan",
    "text": "Asuminen - Asuntokunnat talotyypin ja koon mukaan"
  },
  {
    "objectID": "aluetalous.html",
    "href": "aluetalous.html",
    "title": "Aluetalous ja yritystoiminta",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "aluetalous.html#aloittaneet-ja-lopettaneet-yritykset",
    "href": "aluetalous.html#aloittaneet-ja-lopettaneet-yritykset",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Aloittaneet ja lopettaneet yritykset",
    "text": "Aloittaneet ja lopettaneet yritykset\n\n\n\n\n\n\n\nAloittaneet ja lopettaneet yritykset\nAloittaneita yrityksiä ajanjaksolla 2024Q1 oli yhteensä 65 (lukema 2023Q4: 48). . Lopettaneiden yritysten määrä oli samalla ajanjaksolla yhteensä 98 (lukema 2023Q4: 53).."
  },
  {
    "objectID": "aluetalous.html#avoimet-työpaikat-kuukauden-laskentapäivänä-lkm.",
    "href": "aluetalous.html#avoimet-työpaikat-kuukauden-laskentapäivänä-lkm.",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Avoimet työpaikat kuukauden laskentapäivänä (lkm.)",
    "text": "Avoimet työpaikat kuukauden laskentapäivänä (lkm.)\n\n\n\n\n\n\n\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\nAvoimia työpaikkoja oli 2024M07 yhteensä 92 (lukema 2024M06: 92)."
  },
  {
    "objectID": "aluetalous.html#uudet-avoimet-työpaikat",
    "href": "aluetalous.html#uudet-avoimet-työpaikat",
    "title": "Aluetalous ja yritystoiminta",
    "section": "Uudet avoimet työpaikat",
    "text": "Uudet avoimet työpaikat\n\n\n\n\n\n\n\nAvoimet työpaikat kuukauden laskentapäivänä (lkm.)\nAvoimia työpaikkoja oli 2024M07 yhteensä 59 (lukema 2024M06: 104)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kangasalan kaupunki - heinäkuu, 2024",
    "section": "",
    "text": "Kangasalan kaupunki - heinäkuu, 2024\nTervetuloa kuntien avoimen lähdekoodin kuukausiraporttiin."
  },
  {
    "objectID": "muuttoliike.html",
    "href": "muuttoliike.html",
    "title": "Muuttoliike",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\n\n\n\n\n\n\n\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}\n\n\n\n\n\n\n\nMuuttoliike\n\n\nKuntien välinen muuttoliike\n\ndata = (await FileAttachmentDynamic(migrationChordCSV).csv());\n\n\nchart_chord_d3(data, title_txt_chord,chart_width,chart_height)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDOM.download(() =&gt; serialize(chart_chord_d3(data, title_txt_chord,chart_width,chart_height)), title_txt_chord, \"Save as SVG\")"
  },
  {
    "objectID": "tyollisyys.html",
    "href": "tyollisyys.html",
    "title": "Työllisyys",
    "section": "",
    "text": "d3 = require(\"d3@7\")\n//import {Legend} from \"@d3/color-legend\"\n\nfolderKunnat24TopoJSON = \"./maps/Kunnat2024Topo.json\"\nkunnat2024topo = FileAttachmentDynamic(folderKunnat24TopoJSON).json()\nmapTopoJSON = topojson.feature(kunnat2024topo, kunnat2024topo.objects.Kunnat2024_geo).features\n\n\nfolderMaakunnat24TopoJSON = \"./maps/Maakunnat2024Topo.json\"\nmaakunnat_2024_topo =  FileAttachmentDynamic(folderMaakunnat24TopoJSON).json()\nFileAttachmentDynamic = function(filename) {\n  return new Function(\"FileAttachment\", `return FileAttachment(\"${filename}\")`)(FileAttachment)\n}\n\n// Vaihdetaan tekstin väri\ncolor = function(vari) {\n  if(vari &gt; 0){\n      return \"green\"\n    }else{\n      return \"red\"\n    }\n}\n// Pyöristys\npyoristys = function(n, places) {\n  if (!places) return Math.round(n);\n  const d = 10 ** places;\n  return Math.round(n * d) / d;\n}\n//Euromerkintä\neurot = function(number) {\n  return number.toLocaleString('fi-FI', { style: 'currency', currency: 'EUR',minimumFractionDigits: 0 });\n}\n// Euromuutoksen laskeminen kertoimella\nmuutoskerroin = function(x, y) {\n  return (1+x/100)*y;\n}\n// Muutosprosentti\nmuutosprosentti = function(x, y) {\n  return pyoristys(((x-y)/y)*100,1);\n}\n// Tuhatjakaja\ntuhatjakaja = function(x) {\n  return x/1000;\n}\n// Euromuutoksen laskeminen kertoimella\npalkkakerroin = function(x, y) {\n  return 100*((1+x/100)*(1+y/100)-1);\n}\n// Jako-osuuden asukaskerroin\nasukaskerroin = function(x, y) {\n  return (x/y);\n}\n// Jako-osuuden veroprosenttikerroin miinus1/miinus3 vuotta miinus 1 vuoden kerroin\nveroprosenttikerroin = function(x, y) {\n  return (x/y);\n}\n// Kunnan muok. kunnallisvero, alkuvuosi ja loppuvuosi \nkunnallisvero_muokkaus = function(kunnallisvero,asukaskerroin,veroprosentti) {\n  return kunnallisvero*asukaskerroin*veroprosentti;\n}\n\n//Tekstimuutokset\nfn_nousu_lasku_txt = function(arvo){\n  if(arvo &gt; 0) {\n  return \"kasvanut\" \n  }\n  else { \n  return \"laskenut\";\n  }\n}\n\n//TARVITAAN KARTOISSA\nserialize = {\n  const xmlns = \"http://www.w3.org/2000/xmlns/\";\n  const xlinkns = \"http://www.w3.org/1999/xlink\";\n  const svgns = \"http://www.w3.org/2000/svg\";\n  return function serialize(svg) {\n    svg = svg.cloneNode(true);\n    const fragment = window.location.href + \"#\";\n    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);\n    while (walker.nextNode()) {\n      for (const attr of walker.currentNode.attributes) {\n        if (attr.value.includes(fragment)) {\n          attr.value = attr.value.replace(fragment, \"#\");\n        }\n      }\n    }\n    svg.setAttributeNS(xmlns, \"xmlns\", svgns);\n    svg.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n    const serializer = new window.XMLSerializer;\n    const string = serializer.serializeToString(svg);\n    return new Blob([string], {type: \"image/svg+xml\"});\n  };\n}\n\n\nfunction toSVG(chart) {\n  if (chart.nodeName !== \"FIGURE\") {\n    return chart;\n  }\n\n  // the chart needs to be in the body if we want to read values, positions, sizes…\n  document.body.appendChild(chart);\n  const [x0, y0, width, height] = getBounds([chart]);\n\n  const nodes = [];\n\n  for (const node of d3\n    .select(chart)\n    .selectChildren(\"h1,h2,h3,div,figcaption,svg\")) {\n    switch (node.nodeName.toLowerCase()) {\n      case \"div\":\n        {\n          const children = d3.select(node).selectChildren(\"div,span\");\n          const height = getBounds([node, ...children])[3] + 2;\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n          nodes.push(svg.node());\n\n          const swatches = svg\n            .selectAll()\n            .data(\n              Array.from(children, (d) =&gt; {\n                const svg = d3.select(d).select(\"svg\").node();\n                const bbox = svg.getBBox();\n                return {\n                  style: window.getComputedStyle(d),\n                  svg,\n                  width: bbox.width,\n                  height: bbox.height,\n                  text: d.textContent,\n                  bounds: getBounds([d])\n                };\n              })\n            )\n            .join(\"g\")\n            .attr(\n              \"transform\",\n              (d) =&gt; `translate(${d.bounds[0] - x0},${10 + d.bounds[1] - y0})`\n            );\n\n          swatches\n            .append((d) =&gt; d.svg) // \"rect\")\n            .attr(\"width\", (d) =&gt; d.width)\n            .attr(\"height\", (d) =&gt; d.height)\n            .attr(\"y\", (d) =&gt; `${-parseFloat(d.height) / 2}px`);\n          swatches\n            .append(\"text\")\n            .text((d) =&gt; d.text)\n            .attr(\"x\", (d) =&gt; d.width)\n            .attr(\"dx\", 5)\n            .attr(\"dy\", \"0.38em\")\n            .attr(\"font-family\", (d) =&gt; d.style.fontFamily)\n            .attr(\"font-size\", (d) =&gt; d.style.fontSize)\n            .attr(\"fill\", (d) =&gt; d.style.color);\n        }\n        break;\n      case \"figcaption\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n        {\n          const svg = d3\n            .select(chart)\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"overflow\", \"visible\");\n          nodes.push(svg.node());\n\n          const children = d3.select(node).selectChildren();\n\n          let h = 0;\n          for (const d of children.size() &gt; 0\n            ? children.selectChildren()\n            : [node]) {\n            const style = window.getComputedStyle(d);\n            const t = svg\n              .append(\"g\")\n              .attr(\"transform\", `translate(0,${h})`)\n              .append(() =&gt;\n                d3\n                  .select(\n                    Plot.text([d.textContent], {\n                      text: (d) =&gt; d,\n                      lineWidth:\n                        (1.06 * parseFloat(style.width)) /\n                        parseFloat(style.fontSize),\n                      lineHeight: 1.2,\n                      frameAnchor: \"top-left\"\n                    }).plot()\n                  )\n                  .select(\"text\")\n                  .attr(\"font-family\", style.fontFamily)\n                  .attr(\"font-size\", 1.08 * parseFloat(style.fontSize))\n                  .attr(\"font-weight\", style.fontWeight)\n                  .attr(\"fill\", style.color)\n                  .node()\n              );\n            h += getBounds([t.node()])[3] + 4;\n          }\n          svg.attr(\"height\", h);\n        }\n        break;\n      case \"svg\":\n        d3.select(chart).append(() =&gt; node);\n        nodes.push(node);\n        break;\n    }\n  }\n\n  return serializeAll(nodes)\n    .then((blob) =&gt; blob.text())\n    .then((c) =&gt; {\n      document.body.removeChild(chart);\n      return Object.assign(svg`${c}`, chart);\n    });\n}\n\n\n// Given an array of SVG elements, composites them into a single SVG element,\n// and then serializes the result to a blob.\nasync function serializeAll(elements, {padding = 10} = {}) {\n  const fragment = location.href + \"#\";\n  let root;\n  if (elements.length === 1) {\n    root = elements[0].cloneNode(true); // optimize common case\n  } else {\n    const [ox, oy, dx, dy] = getBounds(elements);\n    root = document.createElementNS(svgns, \"svg\");\n    root.setAttribute(\"width\", dx + 2 * padding);\n    root.setAttribute(\"height\", dy + 2 * padding);\n    root.setAttribute(\"viewBox\", [-padding, -padding, dx + 2 * padding, dy + 2 * padding]);\n    for (const element of elements) {\n      const svg = root.appendChild(element.cloneNode(true));\n      const { x, y, width, height } = element.getBoundingClientRect();\n      svg.setAttribute(\"x\", x - ox);\n      svg.setAttribute(\"y\", y - oy);\n      svg.setAttribute(\"width\", width);\n      svg.setAttribute(\"height\", height);\n    }\n  }\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  while (walker.nextNode()) {\n    const node = walker.currentNode;\n    for (const attr of node.attributes) {\n      if (attr.value.includes(fragment)) {\n        attr.value = attr.value.replace(fragment, \"#\");\n      }\n    }\n  }\n  root.setAttributeNS(xmlns, \"xmlns\", svgns);\n  root.setAttributeNS(xmlns, \"xmlns:xlink\", xlinkns);\n  const serializer = new XMLSerializer();\n  const string = serializer.serializeToString(root);\n  return new Blob([string], { type: \"image/svg+xml\" });\n}\n\n\nfunction getBounds(elements) {\n  let x1 = Infinity;\n  let y1 = x1;\n  let x2 = -x1;\n  let y2 = x2;\n  for (const element of elements) {\n    const { x, y, width, height } = element.getBoundingClientRect();\n    if (x &lt; x1) x1 = x;\n    if (x + width &gt; x2) x2 = x + width;\n    if (y &lt; y1) y1 = y;\n    if (y + height &gt; y2) y2 = y + height;\n  }\n  return [x1, y1, x2 - x1, y2 - y1];\n}\n\n// based on https://observablehq.com/@gka/cheap-fit-text-to-circle\nfunction lines(text, targetWidth) {\n  const CHAR_W = {\n    \"a\":7,\"B\":8,\"C\":8,\"c\":6,\"D\":9,\"f\":4,\"G\":9,\"H\":9,\"I\":3,\"i\":3,\"J\":5,\"j\":3,\"K\":8,\"k\":6,\n    \"l\":3,\"M\":11,\"m\":11,\"N\":9,\"O\":9,\"P\":8,\"Q\":9,\"R\":8,\"r\":4,\"S\":8,\"s\":6,\"t\":4,\"U\":9,\"v\":6,\n    \"W\":11,\"w\":9,\"x\":6,\"y\":6,\"z\":5,\".\":2,\",\":2,\":\":2,\";\":2\n  };\n  function measureWidth(text) { return  d3.sum(text, char =&gt; CHAR_W[char] || CHAR_W[\"a\"]) * 0.8; };\n\n  const words = text.split(\" \");\n  let line;\n  let lineWidth0 = Infinity;\n  const lines = [];\n  for (let i = 0, n = words.length; i &lt; n; ++i) {\n    let lineText1 = (line ? line.text + \" \" : \"\") + words[i];\n    let lineWidth1 = measureWidth(lineText1);\n    if ((lineWidth0 + lineWidth1) / 2 &lt; targetWidth) {\n      line.width = lineWidth0 = lineWidth1;\n      line.text = lineText1;\n    } else {\n      lineWidth0 = measureWidth(words[i]);\n      line = {width: lineWidth0, text: words[i]};\n      lines.push(line);\n    }\n  }\n  return lines;\n}\n\nxmlns = \"http://www.w3.org/2000/xmlns/\"\n\nxlinkns = \"http://www.w3.org/1999/xlink\"\n\nsvgns = \"http://www.w3.org/2000/svg\"\nfunction Legend(color, {\n  title,\n  tickSize = 6,\n  width = 320, \n  height = 44 + tickSize,\n  marginTop = 18,\n  marginRight = 0,\n  marginBottom = 16 + tickSize,\n  marginLeft = 0,\n  ticks = width / 64,\n  tickFormat,\n  tickValues\n} = {}) {\n\n  function ramp(color, n = 256) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = n;\n    canvas.height = 1;\n    const context = canvas.getContext(\"2d\");\n    for (let i = 0; i &lt; n; ++i) {\n      context.fillStyle = color(i / (n - 1));\n      context.fillRect(i, 0, 1, 1);\n    }\n    return canvas;\n  }\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .style(\"overflow\", \"visible\")\n      .style(\"display\", \"block\");\n\n  let tickAdjust = g =&gt; g.selectAll(\".tick line\").attr(\"y1\", marginTop + marginBottom - height);\n  let x;\n\n  // Continuous\n  if (color.interpolate) {\n    const n = Math.min(color.domain().length, color.range().length);\n\n    x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());\n  }\n\n  // Sequential\n  else if (color.interpolator) {\n    x = Object.assign(color.copy()\n        .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),\n        {range() { return [marginLeft, width - marginRight]; }});\n\n    svg.append(\"image\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", width - marginLeft - marginRight)\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"preserveAspectRatio\", \"none\")\n        .attr(\"xlink:href\", ramp(color.interpolator()).toDataURL());\n\n    // scaleSequentialQuantile doesn’t implement ticks or tickFormat.\n    if (!x.ticks) {\n      if (tickValues === undefined) {\n        const n = Math.round(ticks + 1);\n        tickValues = d3.range(n).map(i =&gt; d3.quantile(color.domain(), i / (n - 1)));\n      }\n      if (typeof tickFormat !== \"function\") {\n        tickFormat = d3.format(tickFormat === undefined ? \",f\" : tickFormat);\n      }\n    }\n  }\n\n  // Threshold\n  else if (color.invertExtent) {\n    const thresholds\n        = color.thresholds ? color.thresholds() // scaleQuantize\n        : color.quantiles ? color.quantiles() // scaleQuantile\n        : color.domain(); // scaleThreshold\n\n    const thresholdFormat\n        = tickFormat === undefined ? d =&gt; d\n        : typeof tickFormat === \"string\" ? d3.format(tickFormat)\n        : tickFormat;\n\n    x = d3.scaleLinear()\n        .domain([-1, color.range().length - 1])\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.range())\n      .join(\"rect\")\n        .attr(\"x\", (d, i) =&gt; x(i - 1))\n        .attr(\"y\", marginTop)\n        .attr(\"width\", (d, i) =&gt; x(i) - x(i - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", d =&gt; d);\n\n    tickValues = d3.range(thresholds.length);\n    tickFormat = i =&gt; thresholdFormat(thresholds[i], i);\n  }\n\n  // Ordinal\n  else {\n    x = d3.scaleBand()\n        .domain(color.domain())\n        .rangeRound([marginLeft, width - marginRight]);\n\n    svg.append(\"g\")\n      .selectAll(\"rect\")\n      .data(color.domain())\n      .join(\"rect\")\n        .attr(\"x\", x)\n        .attr(\"y\", marginTop)\n        .attr(\"width\", Math.max(0, x.bandwidth() - 1))\n        .attr(\"height\", height - marginTop - marginBottom)\n        .attr(\"fill\", color);\n\n    tickAdjust = () =&gt; {};\n  }\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x)\n        .ticks(ticks, typeof tickFormat === \"string\" ? tickFormat : undefined)\n        .tickFormat(typeof tickFormat === \"function\" ? tickFormat : undefined)\n        .tickSize(tickSize)\n        .tickValues(tickValues))\n      .call(tickAdjust)\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n        .attr(\"x\", marginLeft)\n        .attr(\"y\", marginTop + marginBottom - height - 6)\n        .attr(\"fill\", \"currentColor\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"font-weight\", \"bold\")\n        .style(\"font-size\", \"12px\")\n        .attr(\"class\", \"title\")\n        .text(title));\n\n  return svg.node();\n}\n\n\nfunction legend({color, ...options}) {\n  return Legend(color, options);\n}\n\n\n// Copyright 2021, Observable Inc.\n// Released under the ISC license.\n// https://observablehq.com/@d3/color-legend\nfunction Swatches(color, {\n  columns = null,\n  format,\n  unknown: formatUnknown,\n  swatchSize = 15,\n  swatchWidth = swatchSize,\n  swatchHeight = swatchSize,\n  marginLeft = 0\n} = {}) {\n  const id = `-swatches-${Math.random().toString(16).slice(2)}`;\n  const unknown = formatUnknown == null ? undefined : color.unknown();\n  const unknowns = unknown == null || unknown === d3.scaleImplicit ? [] : [unknown];\n  const domain = color.domain().concat(unknowns);\n  if (format === undefined) format = x =&gt; x === unknown ? formatUnknown : x;\n\n  function entity(character) {\n    return `&#${character.charCodeAt(0).toString()};`;\n  }\n\n  if (columns !== null) return htl.html`&lt;div style=\"display: flex; align-items: center; margin-left: ${+marginLeft}px; min-height: 33px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id}-item {\n  break-inside: avoid;\n  display: flex;\n  align-items: center;\n  padding-bottom: 1px;\n}\n\n.${id}-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: calc(100% - ${+swatchWidth}px - 0.5em);\n}\n\n.${id}-swatch {\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin: 0 0.5em 0 0;\n}\n\n  &lt;/style&gt;\n  &lt;div style=${{width: \"100%\", columns}}&gt;${domain.map(value =&gt; {\n    const label = `${format(value)}`;\n    return htl.html`&lt;div class=${id}-item&gt;\n      &lt;div class=${id}-swatch style=${{background: color(value)}}&gt;&lt;/div&gt;\n      &lt;div class=${id}-label title=${label}&gt;${label}&lt;/div&gt;\n    &lt;/div&gt;`;\n  })}\n  &lt;/div&gt;\n&lt;/div&gt;`;\n\n  return htl.html`&lt;div style=\"display: flex; align-items: center; min-height: 33px; margin-left: ${+marginLeft}px; font: 12px sans-serif;\"&gt;\n  &lt;style&gt;\n\n.${id} {\n  display: inline-flex;\n  align-items: center;\n  margin-right: 1em;\n}\n\n.${id}::before {\n  content: \"\";\n  width: ${+swatchWidth}px;\n  height: ${+swatchHeight}px;\n  margin-right: 0.5em;\n  background: var(--color);\n}\n\n  &lt;/style&gt;\n  &lt;div&gt;${domain.map(value =&gt; htl.html`&lt;span class=\"${id}\" style=\"--color: ${color(value)}\"&gt;${format(value)}&lt;/span&gt;`)}&lt;/div&gt;`;\n}\n\nfunction swatches({color, ...options}) {\n  return Swatches(color, options);\n}\nchart_map_d3 = function(data, mapTopoJSON, color, colorBorder, txtTitle, chart_width, chart_height) {\n\n  const projection = d3.geoMercator()\n  .scale(1200)\n  //.center([40, 67.5])\n  .center([40, 67.3])\n  .translate([400, 220])\n  const path = d3.geoPath().projection(projection);\n  const format = d =&gt; `${d}%`;\n  \n  //Määritellään tähän muuttujat CSV:stä!!!!!!\n  const valuemap = new Map(data.map(d =&gt; [d.id, d.muutos]));\n  \n  //Määritellään maakunnat\n  const maakuntamesh = topojson.mesh(maakunnat_2024_topo, maakunnat_2024_topo.objects.maakunnat_2024, (a, b) =&gt; a !== b);\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", 900)\n      .attr(\"height\", 650)\n      .attr(\"viewBox\", [0, 0, 900, 650])\n      .on(\"click\", reset);\n      \n  const g = svg.append(\"g\")\n      .attr(\"transform\", \"translate(20,35)\")\n      .append(() =&gt; Legend(color, {title: txtTitle, width: 260}));\n\n  g.append(\"g\")\n    .selectAll(\"path\")\n    .data(mapTopoJSON)\n    .join(\"path\")\n      .attr(\"fill\", d =&gt; color(valuemap.get(d.properties.kunta))) \n      .attr(\"d\", path)\n    .append(\"title\")\n      .text(d =&gt; `${d.properties.name},\\n(${d.properties.nimi_2}),\\n${valuemap.get(d.properties.kunta)}`);\n      \n  g.append(\"path\")\n      .datum(maakuntamesh)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", colorBorder)\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n      \n   svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    g.attr(\"transform\", transform);\n    g.attr(\"stroke-width\", 1 / transform.k);\n  }     \n      \n  return svg.node();\n}\nchart_chord_d3 = function(data, title_txt_chord, chart_width, chart_height) {\n\n  var sum_target;\n  var sum_source;\n  let vari;\n  var sum_yht;\n  \n  const margin = ({top: 20, right: 20, bottom: 0, left: 50});\n  const width = 300;\n  const height = width;\n  const innerRadius = Math.min(width, height) * .3 - 40;\n  const outerRadius = innerRadius + 15;\n  \n  \n  const chord = d3.chordDirected()\n    .padAngle(0.5 / innerRadius)\n    .sortSubgroups(d3.ascending)\n    .sortChords(d3.ascending);\n    \n  const ribbon = d3.ribbon()\n    .radius(innerRadius - 1)\n    .padAngle(0.5 / innerRadius);\n    \n  const rename = name =&gt; name.substring(name.indexOf(\".\") + 1, name.lastIndexOf(\".\"))\n  const names = Array.from(new Set(data.flatMap(d =&gt; [d.source, d.target]))).sort(d3.ascending);\n  \n  function matriisi(names) {\n    const index = new Map(names.map((name, i) =&gt; [name, i]));\n    const matrix = Array.from(index, () =&gt; new Array(names.length).fill(0));\n    for (const {source, target, value} of data) matrix[index.get(source)][index.get(target)] += value;\n    return matrix;\n  }\n\n const matrix = matriisi(names)\n  \n const arc = d3.arc()\n    .innerRadius(innerRadius)\n    .outerRadius(outerRadius)\n\n  //TÄSTÄ ALKAA PIIRROS\n  \n  const zoom = d3.zoom()\n      .scaleExtent([1, 8])\n      .on(\"zoom\", zoomed);\n  \n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-width / 2, -height / 2.5, width, height]);\n\n  const chords = chord(matrix);\n  \n  const group = svg.append(\"g\")\n      .attr(\"font-size\", 3)\n      .attr(\"font-family\", \"Century Gothic\")\n    .selectAll(\"g\")\n    .data(chords.groups)\n    .join(\"g\");\n\n  group.append(\"path\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", arc);\n\n  group.append(\"text\")\n      .each(d =&gt; (d.angle = (d.startAngle + d.endAngle) / 2))\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"transform\", d =&gt; `\n        rotate(${(d.angle * 180 / Math.PI - 90)})\n        translate(${outerRadius + 6})\n        ${d.angle &gt; Math.PI ? \"rotate(180)\" : \"\"}\n      `)\n      .attr(\"text-anchor\", d =&gt; d.angle &gt; Math.PI ? \"end\" : null)\n      //.text(d =&gt; names[d.index])\n      .text(d =&gt; (d.index &gt;= 3) ? names[d.index] : \"\")\n      .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari\n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        });\n\n  group.append(\"title\")\n      .text(d =&gt; `${names[d.index]} \n\n${d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} lähtee →\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.source.value)} tulee ←\n${d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value)- d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value)} netto =`);  \n\n  svg.append(\"g\")\n      .attr(\"fill-opacity\", 0.75)\n    .selectAll(\"path\")\n    .data(chords)\n    .join(\"path\")\n      .style(\"mix-blend-mode\", \"multiply\")\n          .attr(\"fill\", d =&gt; {\n           sum_target = d3.sum(chords, c =&gt; (c.target.index === d.index) * c.target.value);\n           sum_source = d3.sum(chords, c =&gt; (c.source.index === d.index) * c.source.value);\n           sum_yht = sum_target-sum_source;\n            if (sum_yht &gt; 0) { \n              vari = \"#009651\"\n              return vari \n            }\n            else if (sum_yht == 0) { \n              vari = \"#28336C\"\n              return vari \n            }\n            else    { \n              vari = \"#DE232F\" \n              return vari \n            }\n        })\n      .attr(\"d\", ribbon)\n    .append(\"title\")\n      .text(d =&gt; `${names[d.source.index]} --&gt; ${names[d.target.index]} ${d.source.value}`);\n      \n      \n  svg.call(zoom);\n   \n\n  function reset() {\n    // states.transition().style(\"fill\", null);\n    svg.transition().duration(750).call(\n      zoom.transform,\n      d3.zoomIdentity,\n      d3.zoomTransform(svg.node()).invert([chart_width / 2, chart_height / 2])\n    );\n  }\n\n  function zoomed(event) {\n    const {transform} = event;\n    svg.attr(\"transform\", transform);\n    svg.attr(\"stroke-width\", 1 / transform.k);\n  }    \n\n  return svg.node();\n\n\n}"
  },
  {
    "objectID": "tyollisyys.html#työttömien-työnhakijoiden--osuus-työvoimasta-koko-maassa-1",
    "href": "tyollisyys.html#työttömien-työnhakijoiden--osuus-työvoimasta-koko-maassa-1",
    "title": "Työllisyys",
    "section": "Työttömien työnhakijoiden %-osuus työvoimasta koko maassa",
    "text": "Työttömien työnhakijoiden %-osuus työvoimasta koko maassa"
  },
  {
    "objectID": "tyollisyys.html#työttömät-työnhakijat",
    "href": "tyollisyys.html#työttömät-työnhakijat",
    "title": "Työllisyys",
    "section": "Työttömät työnhakijat",
    "text": "Työttömät työnhakijat\n\nTyöttömät työnhakijat laskentapäivänä\n\n\n\n\n\n\nTilastokeskuksen työssäkäyntitilaston mukaan työttömiä työnhakijoita oli 2024M07 yhteensä 1460 (lukema 2024M06: 1422).\n\n\n\n\n\n\n\n\n\n#Työttömien työnhakijoiden %-osuus työvoimasta\n\n\n\n\n\n\n\n\nTyöttömien työnhakijoiden %-osuus työvoimasta (%)\nTyöttömien työnhakijoiden prosenttiosuus työvoimasta oli 2024M07 yhteensä 9 % (lukema 2024M06: 8.8 %)."
  },
  {
    "objectID": "tyollisyys.html#alle-25-v.-työttömät-työnhakijat",
    "href": "tyollisyys.html#alle-25-v.-työttömät-työnhakijat",
    "title": "Työllisyys",
    "section": "Alle 25-v. työttömät työnhakijat",
    "text": "Alle 25-v. työttömät työnhakijat\n\n\n\n\n\n\n:::\n\nAlle 25-v. työttömät työnhakijat (lkm.)\nAlle 25-vuotiaita työttömiä oli 2024M07 yhteensä 185 (lukema 2024M06: 179)."
  }
]